---
tags:
  - db/plan/optimizer
---
# 引言

[相关课程](https://15799.courses.cs.cmu.edu/spring2025/schedule.html)

## 查询优化的重要性

在大规模数据处理环境中，高效的执行计划与低效的执行计划之间，执行速度可能相差几个数量级, 因此，查询优化直接影响数据库系统的整体性能和用户体验

## 查询优化的本质与挑战

SQL 是一种声明式语言，它只描述想要的结果，而不指定如何获得结果。这种抽象带来了极大的便利，但也带来了挑战：
- 同一个 SQL 可能有数十种甚至数百种不同的执行方式
- 不同执行方式的性能差异可能达到数个数量级
- 最优执行方式依赖于数据特征和系统状态

下面拆分得细致一点来讨论
### 搜索空间的复杂性
以一个包含多表 Join 的查询为例，假设有 n 个表参与 Join，则：
- 可能的 Join 顺序有 n! 种
- 每个 Join 操作可能有多种物理实现（Hash Join、Merge Join 等）
- 每个表的访问可能有多种方式（全表扫描、索引扫描等）

这导致整个搜索空间呈组合爆炸式增长。一个看似简单的包含 5 个表的查询，其可能的执行计划就可能达到数千种。

随着数据库应用的发展，现代应用中的查询越来越复杂，可能包含：
- 深层嵌套的子查询
- 复杂的聚合和窗口函数
- 混合使用多种 SQL 特性

这些查询的优化空间更大，传统的动态规划方法可能力不从心。

### 代价估算的不确定性
优化器需要在不实际执行查询的情况下估算执行代价，这本质上是一个预测问题：
- 数据分布可能高度倾斜
	- 大数据时代的特征
		- 表大小可能从GB到PB级别
		- 数据分布更加复杂和倾斜
		- 跨节点数据访问成本显著
- 统计信息可能过时
- 运行时环境可能变化

这就像是在为一次旅程选择路线，但：
- 不知道具体的交通状况
- 天气可能突变
- 路况可能改变

### 优化目标的多样性
不同场景下的优化目标可能不同：
- 总体执行时间
- 首行返回时间
- 资源使用效率
- 并发处理能力

### 运行时环境动态变化
- 系统负载波动
- 数据分布变化
- 并发查询干扰


### 硬件演进

现代硬件特性：
- 多层次内存架构
- SIMD 指令集
- 固态存储
- 高速网络

这些特性为优化提供了新的机会，但也增加了决策的复杂性。

## 相关的理论基础


### 关系代数转换规则
规则基于优化是查询优化的基石，它通过一系列等价变换规则来改进查询计划。这些规则的正确性是由关系代数理论保证的。

1. **选择操作（σ）相关规则**
```

σc1 AND c2(R) ≡ σc1(σc2(R)) -- 选择条件分解

σc(R × S) ≡ σc(R) × S -- 选择下推（当c只涉及R）

σc(R ⋈ S) ≡ σc(R) ⋈ S -- 选择下推到连接

```

2. **投影操作（π）相关规则**
```

πa(πb(R)) ≡ πa(R) -- 投影合并

πa(R × S) ≡ πa(πa∪b(R) × S) -- 投影下推（b为连接所需属性）

```

3. **连接操作（⋈）相关规则**
```

R ⋈ S ≡ S ⋈ R -- 交换律

(R ⋈ S) ⋈ T ≡ R ⋈ (S ⋈ T) -- 结合律

```

  这些规则的重要性在于：
- 允许优化器探索更多可能的执行计划
- 为启发式优化提供理论基础
- 保证优化结果的正确性


## 优化器的历史演进

查询优化器的演变经历了多个重要阶段，每个阶段都引入了新的技术和概念来解决不断增长的数据量和查询复杂性带来的挑战

早期优化器 主要依赖于基于规则的启发式方法来选择执行计划。 这些优化器通常使用预定义的规则集来转换查询，并根据经验法则选择最佳计划。 然而，随着数据量和查询复杂性的增加，基于规则的方法的局限性变得越来越明显。
### System R 时代

为了解决这些局限性，基于成本的优化器在 20 世纪 70 年代后期出现。在此之前，人们并不相信数据库管理系统能比人类更好地构建查询计划。System R 优化器中的许多概念和设计决策至今仍在使用。

- **System R 时代（1970s 末 - 1980s）** System R 优化器是现代数据库优化器的先驱，奠定了其基本范式
	- **动态规划算法** 用于解决连接顺序优化问题
	- **基于代价的优化模型**，使用统计信息估计查询计划的执行代价
	- 建立了重要的 **统计信息收集机制**, 这些概念至今仍在广泛使用
	- **左深树偏好**：优先考虑左深连接树，这种结构更容易流水线化执行。

这些设计选择反映了当时的技术限制和应用需求：
- 计算资源有限，优化本身不能太耗时
- 查询相对简单，主要是 OLTP 场景
- 数据规模较小，估算误差的影响有限

> [An overview of query optimization in relational systems, 1998](zotero://select/library/items/5C39MHB2)

### Volcano/Cascades 时代

Volcano 和 Cascades 优化框架在 20 世纪 90 年代出现，它们为查询优化器带来了重大的突破。该时代以规则驱动的转换机制为核心，实现了可扩展的优化器架构和更灵活的搜索策略。

**Volcano** 优化器生成器采用了一种 **自底向上** 的搜索策略，首先枚举所有等价的逻辑表达式，然后为每个逻辑表达式生成物理执行计划。
**Cascades** 优化框架则采用了一种 **自顶向下** 的搜索策略，首先根据查询生成一个初始的逻辑表达式，然后使用规则逐步将其转换为更高效的逻辑表达式和物理执行计划。Cascades 相比 Volcano 更灵活，因为它允许**使用规则来指导搜索过程**，避免生成不必要的计划。

- **Volcano/Cascades 框架时代（1980s 末 - 至今）** 的优化框架带来了重大突破
	- **规则驱动的转换机制**，使用规则来表达查询计划的等价变换。
	- **可扩展的优化器架构**，允许开发者扩展优化器的功能。
	- **更灵活的搜索策略**，例如自顶向下和自底向上的搜索策略

***

此外, 一些重要的研究论文探讨了 Volcano 和 Cascades 框架的改进和扩展：
- [The Volcano optimizer generator: extensibility and efficient search, 1993](zotero://select/library/items/F2YNHFDK)描述了 Volcano 优化器生成器的设计和实现，并提出了一种基于规则的查询改写方法。
- [The Cascades Framework for Query Optimization](zotero://select/library/items/RVN49D9A) 描述了 Cascades 优化框架的设计和实现，并提出了一些扩展功能，例如对操作符参数的规则操作、逻辑和物理操作符的统一表示以及特定于模式的规则。
- [Exploiting upper and lower bounds in top-down query optimization, 2001](zotero://select/library/items/D4GIJUD8)提出了一种利用上下界来剪枝搜索空间的方法，以提高 Cascades 优化器的效率

### 自适应优化时代
自适应优化技术旨在解决传统优化器在面对复杂查询和动态数据环境时的不足。它们通过**利用运行时信息来改进优化决策**，从而提高查询性能。

以 LEO（DB2's Learning Optimizer）为代表的自适应优化技术开始出现：
- **运行时收集实际执行统计信息**，用于更新代价模型和优化决策。
- **渐进式优化**，在查询执行过程中动态调整执行计划。


一些重要的研究论文探讨了自适应优化技术:
- [LEO – DB2’s LEarning Optimizer](zotero://select/library/items/PNVI4RQB) 描述了 LEO 的设计和实现，它使用反馈机制来学习代价模型和优化规则。
- [Adaptive Query Processing in the Looking Glass](zotero://select/library/items/LF2EVG9F)对自适应查询处理系统进行了分类和比较，并提出了两种新的技术

### **基于机器学习的优化**

这一个部分和自适应优化稍微有些重叠, 基于机器学习的优化技术利用机器学习强大的模式识别和预测能力来解决传统优化器难以处理的问题

- **代价模型学习**，使用机器学习模型来预测查询计划的执行代价。
- **计划选择学习**，使用机器学习模型来选择最优的执行计划。
- **端到端查询优化**，使用深度学习模型来直接将 SQL 查询转换为执行计划。

一些相关的论文
- [Neo: a learned query optimizer](zotero://select/library/items/SV54N8LV)使用深度强化学习来学习查询计划的代价模型，并使用树卷积网络来处理查询计划的树形结构。
- [SkinnerDB: Regret-Bounded Query Evaluation via Reinforcement Learning, 2019](zotero://select/library/items/LAJH9WHJ) 则使用强化学习来在线学习最佳的连接顺序，以最小化查询执行的遗憾值。

# 查询优化器的基本架构

大多数查询优化器遵循一个通用的架构，该架构包括多个阶段，每个阶段负责查询计划的不同方面。这些阶段通常分为逻辑优化和物理优化, 物理优化的部分实际上和执行的关系近一些.

## 逻辑优化阶段 : 消除明显的低效模式

逻辑优化阶段侧重于操作查询的代数表示，而不考虑特定的执行方法, 此阶段的主要目标是通过应用各种基于可证明的等价性规则，显著减少后续优化的搜索空间。



### Join 优化

连接操作是最常见也最耗时的数据库操作之一, 详细的讨论在[[理论/数据库系统/Bottom Up/1-Plan/Optimizer/Join 优化|这里]]



- 确定连接多个关系的最佳顺序。不同的连接顺序会导致显著不同的执行成本。优化器利用动态规划等算法探索各种连接顺序，并使用成本估算技术选择预期成本最低的顺序。

### 谓词下推

[[理论/数据库系统/Bottom Up/1-Plan/Optimizer/谓词下推|谓词下推]]的想法是, 将选择谓词尽可能早地推到查询树中。通过减少中间结果的大小，可以更早地过滤掉不必要的数据，从而提高查询效率。


### 子查询重写

[[理论/数据库系统/Bottom Up/1-Plan/Optimizer/子查询|子查询]]相关的优化是, 
子查询可以被重写为连接或其他操作，以便更有效地处理它们。

查询优化器是最复杂的组件之一. 为了把这种复杂性控制在一定程度以内, 大多数优化器都独立地优化单个 SELECT-FROM-WHERE 查询块, 并不跨块优化. 因此, 许多系统把查询重写为一种更适合优化器的形式, 而不是去想办法使优化器变得更加复杂. 这种转变有时候称为查询规范化. 
规范化的一种类型就是把语义等价查询重写为规范化的形式, 尽量确保语义等价查询被优化后可以产生相同的查询计划. 另一个重要的启发式方法就是平面化嵌套查询, 这样就可以最大程度地为查询优化器单块优化提供机会. 


### 视图合并
如果查询引用了视图，优化器会尝试将视图定义合并到主查询中。这样做可以启用进一步的优化，例如连接顺序优化和谓词下推。

### 表达式化简

- 优化器简化了查询中的逻辑表达式，例如通过应用常量折叠和删除冗余谓词。

通过应用这些技术，优化器可以生成更有效的逻辑查询计划

### 语义优化


用数据库约束和数据分布的知识来进一步简化查询。例如，如果一个关系上定义了一个唯一性约束，则可以消除对该关系的重复消除操作。 



## 计划生成, 比较和选择

逻辑优化阶段通过应用上述所说明的各种优化，会生成多个逻辑上等价，但执行代价可能不同的候选逻辑计划, 因此还需要利用代价模型对这些计划进行评估和比较，最终选择一个最优的计划进入物理优化阶段

### 候选逻辑计划的生成

如果是基于动态规划的搜索, 大体上可以分这么两类
- 自底向上优化器 (例如 Volcano): 首先枚举所有可能的连接顺序，然后应用变换规则生成候选计划。这种方法的搜索空间较大，但可以保证找到最优解。
- 自顶向下优化器 (例如 Cascades): 从初始查询树开始，逐步应用变换规则，生成更优的候选计划, 这种方法的搜索空间相对较小，但可能会错过一些潜在的最优解。

现代优化器通常结合多种策略, 甚至包含遗传算法或者蒙特卡洛, 也有越来越多的优化器采用后面会讨论的自适应优化查询的技术


很多研究论文都探讨了逻辑优化阶段的候选计划生成策略
- [Dynamic programming strikes back, 2008](zotero://select/library/items/WRFVRZ83)提出了一种改进的动态规划方法，可以更高效地枚举连接顺序
- [Exploiting upper and lower bounds in top-down query optimization, 2001](zotero://select/library/items/D4GIJUD8)探讨了如何在自顶向下优化过程中利用上下界来剪枝搜索空间，提高优化效率

### 代价模型

代价模型的目标是量化不同查询计划的执行成本，以便优化器可以选择预期成本最低的计划, 
代价估算是查询优化的核心，它需要解决三个基本问题：
1. 如何估算中间结果的大小？
2. 如何估算操作的执行代价？
3. 如何处理估算的不确定性？

#### 更精确的统计信息 or 不依赖

传统的代价模型通常基于一些简化的假设，例如数据均匀分布、列值独立、统计信息准确等, 为了克服这些问题, 还会有一些像直方图, 或者说采样之类的手段

Real data is often skewed and is tricky to make assumptions about. However, storing every single value of a data set is expensive. One way to reduce the amount of memory used by storing data in a _histogram_ to group together values.

Another approach is to use a equi-depth histogram that varies the width of buckets so that the total number of occurrences for each bucket is roughly the same.

![[理论/数据库系统/Bottom Up/1-Plan/Optimizer/img/Equi-width Histograms.png]]

DBMS’s can use sampling to apply predicates to a smaller copy of the table with a similar distribution. The DBMS updates the sample whenever the amount of changes to the underlying table exceeds some threshold (e.g., 10% of the tuples).
![[理论/数据库系统/Bottom Up/1-Plan/Optimizer/img/Sampling.png]]


1. **单表选择**
	- 均匀分布假设： `selectivity = (high - low) / (max - min)`
	- 直方图：更精确但存储开销大
	- 采样：适用于大表，但有统计误差

2. **多表连接**
	- 独立性假设： `|R ⋈ S| = |R| × |S| / max (|R.k|, |S.k|)`
	- 相关性处理：多维直方图或概率模型

随着计算资源的富余, 我们可以把更多诸如表的大小. 列的基数. 数据的分布, 索引的选择性等信息也纳入统计信息的范畴, 这些信息都对后续的代价估算起到非常关键的作用, 基数估计的准确性直接影响到后续的代价估算, 选择度估计的准确性取决于谓词的复杂度和数据的分布情况, 
- [Exploiting upper and lower bounds in top-down query optimization, 2001](zotero://select/library/items/D4GIJUD8) 中讨论了如何利用上下界来进行基数估计

传统的代价模型是静态的，而自适应代价调整方法可以在查询执行过程中动态地调整代价模型，以适应环境的变化, 例如 [SkinnerDB](zotero://select/library/items/LAJH9WHJ)

#### 考虑更多影响因素

传统的代价模型主要关注磁盘 I/O 成本，但现代代价模型需要考虑更多因素，例如 CPU 成本、内存访问成本、网络通信成本等

总的来说, 大体上可以从下面三个维度进行考虑
- **CPU 代价**
	- 比较操作
	- 哈希计算
	- 排序开销
- **内存代价**
	- 中间结果大小
	- 工作集估算
	- 溢出风险
3. **I/O 代价**
	- 随机 I/O：寻道时间 + 旋转延迟
	- 顺序 I/O：传输时间
	- 缓存影响：命中率和替换策略


- [How good are query optimizers, really?](zotero://select/library/items/I4WNQIRX) 中通过实验对比了 PostgreSQL 的标准代价模型和针对内存环境调优后的代价模型，发现后者能够更准确地预测查询执行时间. 现代数据库系统通常考虑多个维度的代价
- [The MemSQL query optimizer](zotero://select/library/items/K9VKBC3X) 就描述了 MemSQL 查询优化器如何将内存访问成本和网络通信成本纳入代价模型。


此外, 机器学习技术也可以用来构建更精确的代价模型, 通过学习历史查询的执行数据，机器学习模型可以捕捉到传统代价模型难以建模的复杂因素，例如数据倾斜、缓存命中率等，从而提高代价估计的准确性。

例如
-  [Neo: a learned query optimizer](zotero://select/library/items/SV54N8LV) 就提出了一种基于深度强化学习的查询优化器 Neo，它可以学习一个代价模型来预测查询的执行时
- [An end-to-end learning-based cost estimator](zotero://select/library/items/MGHDPRKL) 提出了一种基于深度神经网络的端到端学习型代价估计框架, 该框架能够同时估计代价和基数，并通过树形结构模型有效地学习每个子计划的表示，从而提高代价估计的准确性. 

### 计划比较

优化器会生成并比较所有候选逻辑计划的估算代价, 并根据优化目标 (传统上就是最小化总执行时间) 选择代价最低的计划

值得注意的是，计划评估和比较的过程可能会与候选计划生成交织进行。例如，优化器可以在生成候选计划的过程中，就利用代价模型进行初步的筛选, 尽早丢弃那些明显不合理的计划，从而减少搜索空间的大小。

## 物理优化阶段

物理优化阶段的目标是生成一个详细的执行计划，该计划指定了执行查询所需的所有操作、算法和资源.

物理优化阶段的关键技术包括下面列举的一些, 需要后续进一步补充. 逻辑优化的决策会直接影响物理优化的选择空间, 
#### 访问路径选择
   - Join 顺序影响索引的使用机会
   - 谓词重写影响索引匹配
   - 子查询重写影响执行策略

确定访问关系数据的最佳方式，例如使用表扫描或索引扫描。优化器会考虑索引的可用性和选择性，以及数据的物理存储方式。

#### 连接算法选择

选择最有效的算法来执行连接操作，例如哈希连接、归并连接或嵌套循环连接。优化器会根据关系的大小、连接条件和可用内存来选择最佳算法。

#### 物理算子选择

为其他关系代数运算选择特定的实现算法，例如排序、聚合和分组。优化器会考虑数据的排序顺序、数据分布和系统资源来选择最佳算法。
#### 并行执行机会

将查询操作分解成可以并行执行的子任务，以利用多处理器系统或分布式数据库环境。优化器会考虑数据的划分方式、网络通信成本和系统负载来确定最佳并行策略。

   - 算子依赖关系决定并行可能性
   - 数据流特征影响并行策略
   - 中间结果大小影响资源分配

#### 内存管理策略
   - 算子的执行顺序影响内存峰值
   - 中间结果的生命周期管理
   - 流水线合并的可能性

#### 压缩感知


# 现代优化器关键技术

需要进一步补充

## 自适应查询优化

传统的"优化后执行"模型在面对数据倾斜、统计信息不准确, 运行环境的稳定性等问题时表现不佳, 考虑以下场景：

```sql
SELECT c.name, SUM(o.amount)
FROM customers c 
JOIN orders o ON c.id = o.customer_id
WHERE o.date BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY c.name
HAVING SUM(o.amount) > 10000;
```

在传统优化中，优化器会：
1. 基于统计信息估算中间结果大小
2. 选择 Join 算法（Hash Join/Merge Join）
3. 决定执行顺序


但如果：
- 数据高度倾斜（某些客户的订单数远超平均值）
- 内存压力波动（其他查询竞争内存资源）
- 统计信息过期（数据分布发生变化）

这些预先决策就可能导致次优的执行计划, 自适应查询优化 (AQP) 技术旨在克服传统优化器在面对不准确的成本估算、不断变化的数据特征和意外的系统负载时的局限性, AQP 系统通过在查询执行期间或执行后监视查询性能，并在必要时调整执行计划来实现这一点。

AQP 技术可以分为以下几类：
- 基于采样的 AQP: 在查询执行期间采样数据，并使用采样结果来改进成本估算和计划选择。
- 基于反馈的 AQP: 使用查询执行的实际性能数据来更新成本模型和优化规则。
- 基于预测的 AQP: 使用机器学习和其他预测技术来预测查询性能，并在必要时调整执行计划。

- AQP 技术的优点:
	- 能够适应不断变化的数据特征和系统负载
	- 能够提高查询性能和资源利用率
	- 能够减少优化器的开销
- AQP 技术的挑战:
	- 需要有效的监视和反馈机制
	- 需要高效的计划调整算法
	- 需要平衡适应性和稳定性

[Adaptive Query Processing in the Looking Glass](zotero://select/library/items/LF2EVG9F)

 自适应查询处理通过在执行过程中收集信息并动态调整执行计划来解决这个问题。

自适应查询处理通过以下机制解决这个问题：
1. 运行时统计收集
	- 监控执行统计信息
	- 检测计划偏差
```python
class AdaptiveOperator:
    def process_batch(self, batch):
        # 收集运行时统计
        self.update_statistics(batch)
        
        # 检查是否需要改变计划
        if self.should_reoptimize():
            new_plan = self.reoptimize()
            self.switch_to_plan(new_plan)
        
        return self.execute(batch)
```

2. 动态计划调整
	- 动态调整执行策略
		- 并行度的自动调整
		- 切换 Join 算法
		- 重排执行顺序
	- 内存使用自适应


## 基于机器学习的优化

传统代价模型依赖于简化的假设，例如：
- 数据分布均匀
- 列值独立
- 统计信息准确

这些假设在实际数据中经常不成立。考虑以下查询：

```sql
SELECT * FROM orders
WHERE region = 'Asia' 
  AND category = 'Electronics'
  AND price BETWEEN 100 AND 1000;
```

传统方法会假设选择条件独立，估算基数：
```python
selectivity = sel(region='Asia') * sel(category='Electronics') * sel(price_range)
```

但实际上这些属性可能高度相关：
- 不同地区的商品类别分布不同
- 不同类别的价格区间差异很大

机器学习模型可以：
1. **捕捉复杂的数据相关性**
   ```python
   class LearnedCardinalityModel:
       def __init__(self):
           self.model = train_deep_model()
           
       def estimate_cardinality(self, query_features):
           # 提取查询特征
           features = self.featurize(query_features)
           
           # 使用模型预测
           return self.model.predict(features)
   ```

2. **适应数据分布变化**
   - 在线学习更新模型
   - 检测分布漂移
   - 自动触发重训练

机器学习 (ML) 技术越来越多地应用于查询优化，以提高成本估算的准确性、学习有效的优化规则和自动调整优化器参数, 基于 ML 的优化器可以从历史查询执行数据中学习，并利用这些知识来预测未来的查询性能。

[Neo: a learned query optimizer](zotero://select/library/items/SV54N8LV)

基于机器学习的查询优化技术可以分为以下几类：
- 学习型代价模型: 使用机器学习技术来学习更准确的代价模型，例如回归模型、神经网络和决策树。
- 学习型优化规则: 使用机器学习技术来学习有效的优化规则，例如强化学习、遗传算法和模拟退火。
- 端到端查询优化: 使用深度学习技术来学习端到端的查询优化模型，例如递归神经网络和图神经网络。

## 多目标优化

传统的查询优化器主要关注最小化查询执行时间。然而，在许多实际应用中，还有其他重要的优化目标，例如最小化资源消耗、满足服务级别协议 (SLA) 或最大化查询吞吐量, 多目标优化技术旨在找到满足多个优化目标的执行计划。

多目标优化技术可以分为以下几类：
- 基于帕累托最优的优化: 找到一组帕累托最优解，即在任何一个目标上都不能改进而不损害其他目标的解。
- 基于约束的优化: 将一些优化目标转换为约束条件，并在满足这些约束条件的前提下优化其他目标。
- 基于权重的优化: 为每个优化目标分配一个权重，并将所有目标的加权和作为最终的优化目标。


## 场景优化

除了通用查询优化技术之外，针对特定应用场景，例如分布式数据库、流式查询和 OLAP 查询，还需要专门的优化技术。

### 分布式查询优化

在分布式数据库环境中，查询优化器需要考虑数据分布、网络通信成本和数据复制等因素。分布式查询优化器可以使用数据局部性、数据分区和并行执行等技术来提高查询效率, 它至少包含以下几个关键点

- 数据位置感知
- 网络代价考虑
- 分布式连接优化

分布式查询优化技术可以分为以下几类：
- 数据局部性: 将查询操作尽可能地推送到数据所在的节点上执行，以减少网络通信成本。
- 数据分区: 将数据划分到多个节点上，以提高查询的并行度。
- 并行执行: 将查询操作分解成可以并行执行的子任务，以利用多个节点的计算资源。

[The MemSQL query optimizer: a modern optimizer for real-time analytics in a distributed database, ](zotero://select/library/items/K9VKBC3X)


### 流式查询优化

流式查询是在连续的数据流上执行的查询，需要优化器能够处理数据到达的动态性和查询结果的时效性, 流式查询优化器可以使用滑动窗口、增量计算和近似查询处理等技术来满足这些需求。

- 连续查询优化
- 状态管理优化
- 延迟优化

流式查询优化技术可以分为以下几类：
- 滑动窗口: 定义一个时间窗口，并仅处理窗口内的数据。
- 增量计算: 在数据流更新时，仅更新查询结果中受影响的部分。
- 近似查询处理: 使用近似算法来处理查询，以减少计算成本和延迟。


### OLAP 查询优化
- 物化视图选择
- 预计算优化
- 聚合优化

olap 查询通常涉及对大型数据集执行复杂的聚合操作, OLAP 查询优化器可以使用物化视图、预计算、多维索引和并行处理等技术来提高查询性能。

- 物化视图: 预先计算和存储查询结果，以减少查询执行时间
- 预计算: 预先计算一些聚合结果，以减少查询执行时间
- 多维索引: 使用多维索引来加速对多维数据的访问

此外, 在列式存储系统中，数据按列组织带来了独特的优化机会
#### 延迟物化

最核心的是延迟物化（Late Materialization）策略

考虑一个简单的查询：
```sql
SELECT name, salary 
FROM employees 
WHERE department = 'IT' AND salary > 100000
```

在传统的行存储中，我们需要：
1. 读取整行数据
2. 检查 department
3. 检查 salary
4. 输出符合条件的 name 和 salary

而在列存储中，我们可以：
1. 只读取 department 列，找到'IT'部门的位置
2. 只读取这些位置的 salary 值，进行过滤
3. 最后才读取需要的 name 列

这种策略带来的好处是显而易见的：
- 减少 I/O：只读取必要的列
- 提高缓存效率：数据更紧凑
- 更好的压缩效果：同类数据放在一起

#### 列裁剪
此外，列裁剪（Column Pruning）是另一个重要的优化技术。它在查询分析阶段就识别出查询所需的列，避免读取不必要的数据。这个优化虽然概念简单，但效果显著，特别是在宽表场景下


#### 压缩感知

列存系统中，压缩不仅是存储问题，也是查询优化问题：
1. **直接操作压缩数据**
	- 避免解压缩开销
	- 利用压缩格式的特性


# 未来发展方向

随着数据管理技术的不断发展，查询优化领域仍然存在许多研究方向，例如

## 自学习与自调优

自学习和自调优优化器能够自动学习数据特征、查询模式和系统行为，并根据这些信息动态调整优化策略和参数。例如，优化器可以学习代价模型、优化规则和并行化策略。

## 跨平台优化

在当今异构数据管理环境中，跨平台优化器需要能够处理来自不同数据源、使用不同数据模型和运行在不同平台上的数据。例如，优化器需要能够处理关系型数据库、NoSQL 数据库和 Hadoop 系统中的数据。

## 新硬件适配优化

新硬件技术，例如 GPU、FPGA 和新型存储介质，为查询优化提供了新的机遇和挑战。优化器需要能够利用这些新硬件的特性来提高查询性能。例如，优化器可以利用 GPU 的并行计算能力来加速查询执行。

新硬件架构不断涌现：
- 异构计算平台
- 新型存储设备
- NUMA 架构

优化器需要能够：
- 理解硬件特性
- 利用硬件优势
- 避免硬件瓶颈

## 云原生环境
云计算环境带来新的挑战：
- 资源弹性伸缩
- 多租户干扰
- 网络延迟影响

这要求优化器能够：
- 适应资源变化
- 处理不确定性
- 优化数据移动