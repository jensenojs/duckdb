
### 谓词下推

谓词下推是查询优化中最基础也最重要的优化技术之一。它的核心思想是：尽可能早地过滤数据，减少中间结果集的大小。

#### 基本下推规则

1. **投影算子下推**
```sql
-- 原始查询
SELECT t1.a, t2.b 
FROM t1 JOIN t2 ON t1.id = t2.id 
WHERE t1.a > 10

-- 优化后等价形式
SELECT * FROM
(SELECT a, id FROM t1 WHERE a > 10) t1
JOIN 
(SELECT b, id FROM t2) t2
ON t1.id = t2.id
```

2. **连接算子下推**
```sql
-- 对于连接条件 R ⋈ S
σ(condition)(R ⋈ S) ≡ 
  case
    when condition只涉及R: σ(condition)(R) ⋈ S
    when condition只涉及S: R ⋈ σ(condition)(S)
    when condition可分解: σ(conditionR)(R) ⋈ σ(conditionS)(S)
```

3. **聚合算子下推**
```sql
-- 原始查询
SELECT dept, SUM(salary) 
FROM employee 
WHERE age > 30 
GROUP BY dept

-- 优化后
SELECT dept, SUM(salary) 
FROM (SELECT * FROM employee WHERE age > 30) 
GROUP BY dept
```

#### 谓词合并与拆分

谓词处理的一个关键是合理地拆分和合并谓词，使其能够更好地下推：

1. **合取条件拆分**
```sql
-- 原始条件
WHERE a > 10 AND b < 20 AND c = 'd'

-- 拆分后
WHERE a > 10 AND (b < 20 AND c = 'd')
```

2. **析取条件处理**
```sql
-- 原始条件
WHERE (a = 1 AND b = 2) OR (a = 3 AND b = 4)

-- 重写为
WHERE a IN (1,3) AND 
      ((a = 1 AND b = 2) OR (a = 3 AND b = 4))
```

3. **复杂表达式重写**
```sql
-- 原始条件
WHERE COALESCE(a, 0) > 10

-- 重写为
WHERE a > 10 OR (a IS NULL AND 0 > 10)
```

#### 特殊场景处理

1. **外连接场景**
```sql
-- 左外连接的谓词下推需要特别小心
SELECT * FROM R LEFT JOIN S ON R.id = S.id
WHERE S.val > 10

-- 这会改变结果语义！不能简单下推
-- 正确的处理是转换为内连接
SELECT * FROM R INNER JOIN S ON R.id = S.id
WHERE S.val > 10
```

2. **子查询场景**
```sql
-- 相关子查询
SELECT * FROM R 
WHERE EXISTS (
    SELECT 1 FROM S 
    WHERE S.id = R.id AND S.val > 10
)

-- 优化为连接
SELECT DISTINCT R.* FROM R 
INNER JOIN S ON R.id = S.id 
WHERE S.val > 10
```

3. **NULL 值处理**
```sql
-- 需要特别注意NULL值的语义
WHERE col = 10 OR col IS NULL

-- 不能简单重写为
WHERE COALESCE(col, 10) = 10
```

#### 实现考虑

在实现谓词下推时，需要考虑以下因素：

1. **代价评估**
```python
class PredicatePushdown:
    def should_pushdown(self, predicate, target):
        # 估算下推收益
        original_cost = self.estimate_cost(predicate, target)
        pushdown_cost = self.estimate_pushdown_cost(predicate, target)
        
        # 考虑过滤率
        selectivity = self.estimate_selectivity(predicate)
        
        return pushdown_cost + selectivity * original_cost < original_cost
```

2. **执行计划缓存**
- 缓存常见谓词模式
- 记录历史执行统计
- 自适应调整策略

3. **并行执行考虑**
- 谓词下推可能影响并行度
- 需要权衡过滤和并行
- 考虑数据分布影响


