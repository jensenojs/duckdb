---
tags:
  - db/plan/optimizer
---
查询优化器是最复杂的组件之一. 为了把这种复杂性控制在一定程度以内, 大多数优化器都独立地优化单个 SELECT-FROM-WHERE 查询块, 并不跨块优化. 因此, 许多系统把查询重写为一种更适合优化器的形式, 而不是去想办法使优化器变得更加复杂. 这种转变有时候称为查询规范化. 

规范化的一种类型就是把语义等价查询重写为规范化的形式, 尽量确保语义等价查询被优化后可以产生相同的查询计划. 另一个重要的启发式方法就是平面化嵌套查询, 这样就可以最大程度地为查询优化器单块优化提供机会. 

# 分类

我们大体上可以把子查询分成下面这几类, 每种类型可以应用不同的优化规则

- 标量子查询 (SCALAR)
	- 返回单个值的子查询
	- 例如： `SELECT (SELECT MAX(x) FROM t2) FROM t1`
	- 包括相关子查询： `SELECT (SELECT MAX(x) FROM t2 WHERE t2.id = t1.id) FROM t1`
	- 如果是非相关子查询, 在执行过程中只需要计算一次, 后续可以冲用这个结果
```sql
-- 非相关子查询
SELECT id, name, (SELECT MAX(salary) FROM salaries) as max_salary
FROM employees;

-- 可以转换为
WITH max_sal AS (
    SELECT MAX(salary) FROM salaries
)
SELECT id, name, (SELECT * FROM max_sal) as max_salary
FROM employees;
```
- 存在性测试 (EXISTS/NOT_EXISTS)
	- EXISTS 子查询： `WHERE EXISTS (SELECT * FROM t2 WHERE t2.id = t1.id)`
	- NOT EXISTS 子查询： `WHERE NOT EXISTS (SELECT * FROM t2 WHERE t2.id = t1.id)`
	- 只需要知道是否存在匹配的行，不需要计算具体值, 还可以提前终止扫描
	- 常用于连接消除优化
		- 如果不优化, 那就是嵌套循环的方式
			- 对于外表的每一行, 执行一次子查询
		- 优化就是先执行子查询得到结果集
			- 对外表的每一行检查是否满足条件
```sql
-- 原始查询
SELECT * FROM orders o 
WHERE EXISTS (
    SELECT 1 FROM order_details od 
    WHERE od.order_id = o.id
);

-- 可以优化为
SELECT DISTINCT o.* 
FROM orders o 
JOIN order_details od ON od.order_id = o.id;
```
- 比较子查询 (ANY)
	- IN 子查询： `WHERE x IN (SELECT id FROM t2)`
	- ANY/SOME 子查询： `WHERE x > ANY (SELECT salary FROM t2)`
	- ALL 子查询： `WHERE x > ALL (SELECT salary FROM t2)
	- 可以转换为半连接 (semi-join) 或反连接 (anti-join)
	- 可以使用索引优化
	- 可以进行[[理论/数据库系统/Bottom Up/1-Plan/Optimizer/谓词下推|谓词下推]]
```sql
WHERE x IN (SELECT id FROM t2)  -- 可以转换为semi-join
WHERE x > ALL (SELECT salary FROM t2)  -- 可以转换为 x > MAX(salary)
```






1. **相关性分类**
```sql
-- 不相关子查询
SELECT * FROM orders
WHERE amount > (SELECT AVG(amount) FROM orders)

-- 相关子查询
SELECT * FROM orders o
WHERE amount > (
    SELECT AVG(amount) 
    FROM orders sub 
    WHERE sub.user_id = o.user_id
)
```

2. **返回值分类**
```sql
-- 标量子查询
SELECT name, (SELECT MAX(amount) FROM orders) as max_amount
FROM users

-- 行子查询
SELECT * FROM orders
WHERE (user_id, amount) IN (
    SELECT user_id, MAX(amount)
    FROM orders
    GROUP BY user_id
)

-- 表子查询
SELECT * FROM (
    SELECT user_id, SUM(amount) as total
    FROM orders
    GROUP BY user_id
) t
WHERE total > 1000
```

# 子查询优化策略

1. **去相关化**
```sql
-- 原始查询
SELECT * FROM orders o
WHERE amount > (
    SELECT AVG(amount)
    FROM orders sub
    WHERE sub.user_id = o.user_id
)

-- 转换为Join
SELECT o.* FROM orders o
JOIN (
    SELECT user_id, AVG(amount) as avg_amount
    FROM orders
    GROUP BY user_id
) sub ON o.user_id = sub.user_id
WHERE o.amount > sub.avg_amount
```

2. **子查询上拉**
```sql
-- 原始查询
SELECT * FROM (
    SELECT * FROM orders
    WHERE amount > 100
) t
WHERE user_id IN (
    SELECT id FROM users
    WHERE country = 'US'
)

-- 优化后
SELECT * FROM orders
WHERE amount > 100
  AND user_id IN (
    SELECT id FROM users
    WHERE country = 'US'
)
```

3. **EXISTS 转换**
```sql
-- 原始查询
SELECT * FROM orders o
WHERE EXISTS (
    SELECT 1 FROM users u
    WHERE u.id = o.user_id
    AND u.country = 'US'
)

-- 转换为Join
SELECT DISTINCT o.*
FROM orders o
JOIN users u ON u.id = o.user_id
WHERE u.country = 'US'
```

# 实现技术

1. **子查询识别与分析**
```python
class SubqueryAnalyzer:
    def analyze(self, query):
        # 识别子查询类型
        subqueries = self.find_subqueries(query)
        for subq in subqueries:
            # 检查相关性
            if self.is_correlated(subq):
                correlated_cols = self.find_correlation(subq)
                if self.can_decorrelate(subq, correlated_cols):
                    return self.decorrelate(subq, correlated_cols)
            else:
                # 处理不相关子查询
                if self.is_invariant(subq):
                    return self.convert_to_constant(subq)
                else:
                    return self.optimize_independent(subq)
```

2. **子查询重写规则**
```python
class SubqueryRewriter:
    def rewrite_exists(self, query):
        # EXISTS转Semi-join
        if self.is_exists_query(query):
            return self.to_semi_join(query)
    
    def rewrite_in(self, query):
        # IN转Join
        if self.is_in_query(query):
            if self.should_use_hash_join(query):
                return self.to_hash_join(query)
            else:
                return self.to_merge_join(query)
    
    def rewrite_scalar(self, query):
        # 标量子查询处理
        if self.is_scalar_query(query):
            if self.is_aggregate(query):
                return self.to_join_with_aggregate(query)
            else:
                return self.to_simple_join(query)
```

3. **执行优化**
```python
class SubqueryExecutor:
    def execute_subquery(self, query, context):
        # 缓存子查询结果
        if self.is_cacheable(query):
            cached_result = self.get_from_cache(query)
            if cached_result:
                return cached_result
        
        # 流式处理
        if self.can_stream(query):
            return self.stream_execute(query)
        
        # 批量处理
        return self.batch_execute(query)
```

# 特殊场景处理

1. **ANY/ALL 优化**
```sql
-- 原始查询
SELECT * FROM orders
WHERE amount > ALL (
    SELECT amount
    FROM orders
    WHERE user_id = 'VIP'
)

-- 转换为聚合
SELECT * FROM orders
WHERE amount > (
    SELECT MAX(amount)
    FROM orders
    WHERE user_id = 'VIP'
)
```

2. **相关更新**
```sql
-- 原始查询
UPDATE orders o
SET total = (
    SELECT SUM(amount)
    FROM order_items oi
    WHERE oi.order_id = o.id
)

-- 优化为Join
UPDATE orders o
SET total = t.total
FROM (
    SELECT order_id, SUM(amount) as total
    FROM order_items
    GROUP BY order_id
) t
WHERE o.id = t.order_id
```

3. **嵌套子查询**
```sql
-- 复杂嵌套查询
SELECT * FROM orders o
WHERE amount > (
    SELECT AVG(amount)
    FROM orders s1
    WHERE user_id IN (
        SELECT user_id
        FROM users
        WHERE country = o.country
    )
)

-- 分步优化
-- 1. 内层子查询转Join
-- 2. 聚合下推
-- 3. 相关性消除
```


