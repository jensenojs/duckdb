逻辑计划生成是数据库查询处理的核心环节，它将 SQL 这样的声明式查询语言转换为数据库系统内部的逻辑执行计划。这个过程不仅需要保证语义的正确性，还需要为后续的优化提供充分的机会, 虽然优化器其实也可以算是在逻辑计划的内部的组织形式.
![[理论/数据库系统/Bottom Up/1-Plan/img/Architecture Overview.png]]
# 关系代数基础

关系代数的基本运算构成了逻辑计划的骨架：

1. **选择 (σ)**：
   - 形式：σ_p (R)，其中 p 是谓词，R 是关系
   - 语义：从关系 R 中选出满足谓词 p 的元组
   - 特性：
     - 可交换性：`σ_p1 (σ_p2 (R)) ≡ σ_p2 (σ_p1 (R))`
     - 合并性：`σ_p1 AND p2 (R) ≡ σ_p1 (σ_p2 (R))`
2. **投影 (π)**：
   - 形式：π_A (R)，其中 A 是属性集合
   - 语义：选择关系 R 中的特定列
   - 特性：
     - 串接性：`π_A (π_B (R)) ≡ π_A (R)`，当 `A ⊆ B`
     - 分配性：`π_A (σ_p (R)) ≡ σ_p (π_A (R))`，当 p 只涉及 A 中的属性
3. **连接 (⋈)**：
   - 形式：`R ⋈_p S`，其中 p 是连接条件
   - 语义：基于条件 p 组合两个关系的元组
   - 特性：
     - 交换性：`R ⋈_p S ≡ S ⋈_p R`
     - 结合性：`(R ⋈ S) ⋈ T ≡ R ⋈ (S ⋈ T)`

#### 扩展运算

现代数据库系统还需要支持更复杂的操作：

1. **聚合 (γ)**：
   - 形式：γ_G,agg (R)，其中 G 是分组属性，agg 是聚合函数
   - 语义：按 G 分组计算聚合值
   - 特性：
     - 分布式计算：`COUNT`、`SUM` 等可分布式计算
     - 部分聚合：某些场景下可以提前执行部分聚合

2. **窗口函数 (ω)**：
   - 形式：`ω_[partition][order][frame](R)`
   - 语义：在分区内按指定方式计算
   - 特性：
     - 保序性：结果需保持原有顺序
     - 并行限制：某些窗口函数难以并行化

### 树形表示

逻辑计划采用树形结构表示关系代数表达式，这种表示方式具有多重优势：

1. **数据流表达**：
   - 自底向上的数据流向
   - 清晰的依赖关系
   - 便于流水线执行

2. **局部性**：
   - 转换规则可以局部应用
   - 优化可以分而治之
   - 执行可以分段流水线



# 从绑定树到逻辑计划

在经过语法分析和语义绑定后，查询会形成一个绑定树（Bound Tree）。这个绑定树虽然解决了名称解析和类型检查的问题，但它的结构仍然紧跟 SQL 语法，这带来了一些问题, 看下面两个例子

   ```sql
   -- 一个典型的嵌套查询
   SELECT * FROM orders WHERE 
     amount > (SELECT AVG(amount) FROM orders)
   ```
   这样的查询在绑定树中会形成嵌套结构，使得优化器难以全局考虑执行策略。

   ```sql
   SELECT customer_name, SUM(amount) 
   FROM customers JOIN orders 
   ON customers.id = orders.customer_id
   WHERE orders.date > '2023-01-01'
   GROUP BY customer_name
   ```
SQL 的语法顺序（FROM -> WHERE -> GROUP BY -> SELECT）并不一定是最优的执行顺序。

这是因为 SQL 是一种声明式的语言因此，我们需要一个转换过程，将绑定树转换为基于关系代数的逻辑计划, 并且要在一系列的等价转换上追求更高效的执行方式.

## 转换过程

下面我们来看转换的过程中需要保证或者说争取的

1. **语义保持**：
   转换过程必须确保查询语义的完整保持。例如：
   ```sql
   SELECT DISTINCT a, b 
   FROM T 
   WHERE a > 10 
   ORDER BY b
   ```
   这个查询包含了选择、投影、去重和排序等多个语义要素，转换时必须正确处理它们的相互关系。

2. **作用域处理**：
   需要正确处理不同层次的作用域，特别是在处理子查询时：
   ```sql
   SELECT * FROM T1 
   WHERE x IN (SELECT x FROM T2 WHERE T2.y > T1.y)
   ```
   这里需要维护内外层查询的关系，并为优化器预留重写空间。

除此之外, 还有诸多内容, 包括但不限制于
- **子查询处理**：
   - 相关子查询的识别和标注
   - 限定作用域的维护
   - 重写机会的保留
   例如，对于 EXISTS 子查询：
   ```sql
   SELECT * FROM orders o 
   WHERE EXISTS (
     SELECT 1 FROM items i 
     WHERE i.order_id = o.id AND i.price > 100
   )
   ```
   需要保留将其重写为半连接的可能性。
- **视图展开**：
   - 视图定义的内联
   - 公共表达式的识别
   - 视图约束的传递
- **表达式转换**：
   - 类型转换的规范化
   - 条件表达式的标准化
   - 计算表达式的化简

等等内容

# 逻辑算子体系
一个设计良好的逻辑算子体系应该满足以下要求：

1. **完备性**：能够表达所有 SQL 查询语义
2. **正交性**：算子之间相互独立，便于组合
3. **可优化性**：提供足够的转换空间

常见的逻辑算子包括：

1. **数据源算子**
   - TableScan: 表示对基表的访问
   - IndexScan: 表示通过索引的访问
   - ViewScan: 表示对视图的访问
   - ValueScan:

2. **过滤算子**
   - Filter：实现 WHERE 和 HAVING 子句
   - 支持任意复杂的条件表达式
   - 可以下推到数据源

3. **连接算子**
   - InnerJoin：内连接
   - LeftJoin：左外连接
   - CrossJoin：笛卡尔积
   每个连接算子都带有连接条件

4. **聚合算子**
   - Aggregate：实现 GROUP BY 和聚合函数
   - 支持分组表达式
   - 处理 DISTINCT 等修饰符

5. **投影算子**
   - Project：选择和计算输出列
   - 支持表达式计算
   - 处理列别名

此外, 数据库为了达成一些特殊的优化可能会做各种奇怪的算子

逻辑计划虽然专注于查询语义的正确表达，但其设计必须考虑优化器的需求。这种考虑体现在多个层面

# 优化器 : 面向优化的逻辑计划设计

优化器是数据库系统中最复杂的组件之一，它的核心任务是将逻辑计划转换为高效的执行计划。完整详细的综述可以看[[理论/数据库系统/Bottom Up/1-Plan/Optimizer/数据库查询优化器综述|数据库查询优化器综述]]

在这个过程中，优化器需要考虑多个维度的因素：

首先，优化器需要保留足够的查询语义信息。例如，在处理子查询时，不能过早地决定采用相关子查询还是去相关化处理，而应该保留两种可能性，让优化器基于成本进行选择。其次，逻辑计划应该标记潜在的优化机会。比如在构建连接树时，虽然采用左深树形式，但要保留足够的信息，使优化器能够探索 bushy 树等其他可能的结构。

在统计信息方面，逻辑计划阶段就需要开始收集和维护基础的统计数据。这些数据不仅包括表的大小、列的基数等静态信息，还包括算子的选择性估计等动态信息。这些信息为优化器的成本估算提供基础。例如，在处理一个包含复杂谓词的查询时：
```sql
SELECT * FROM orders o 
JOIN customers c ON o.customer_id = c.id
WHERE o.amount > 1000 AND c.region = 'Asia'
```

逻辑计划需要估算每个谓词的选择性，并考虑谓词间的相关性，这些信息直接影响优化器对连接顺序的选择。

## 优化器的核心任务和组件

优化器的核心任务可以分为以下几个方面：

1. **逻辑优化**
   - 应用代数转换规则消除明显的低效模式
   - 进行谓词下推、子查询重写等基础优化
   - 利用数据库约束和统计信息进行语义优化

2. **物理优化**
   - 选择具体的执行算法（如连接算法的选择）
   - 确定访问路径（全表扫描 vs 索引扫描）
   - 决定并行执行策略

这一部分事情只是要做, 但是不是由优化器来做就两说

3. **代价估算**
   - 维护和更新统计信息
   - 估算中间结果大小
   - 评估不同执行计划的代价

## 常见优化的枚举

1. **基础优化**
   - 谓词下推：尽早过滤数据
   ![[理论/数据库系统/Bottom Up/1-Plan/img/谓词下推-e.g.1.png]]
   - 列裁剪：减少数据传输量
	   ![[理论/数据库系统/Bottom Up/1-Plan/img/谓词下推-e.g.2.png]]
   - 常量折叠：提前计算常量表达式
   - 合并谓词
	   ![[理论/数据库系统/Bottom Up/1-Plan/img/merge predicate.png]]

2. **复杂查询优化**
   - 子查询扁平化：将嵌套查询转换为连接
	   ![[理论/数据库系统/Bottom Up/1-Plan/img/flattening.png]]
   - 视图合并：将视图定义内联到主查询
   - 公共子表达式识别：避免重复计算

3. **连接优化**
   - 连接顺序选择：考虑表大小和选择性
   - 连接算法选择：根据数据特征选择最优算法
   - 连接树结构优化：考虑左深树、右深树或 bushy 树

3. **并行执行优化**
   - 数据分区策略：确保负载均衡
   - 并行度选择：根据系统资源和查询特征
   - 流水线执行：最大化资源利用

## 动态优化支持

现代数据库系统越来越多地采用动态优化技术，这要求逻辑计划具备足够的适应性。具体来说，逻辑计划需要：

1. 支持运行时的计划调整。例如，当发现某个算子的选择性估计与实际情况差异较大时，能够快速调整执行策略。

2. 提供检查点机制。在关键的执行阶段设置检查点，收集实际的执行统计信息，这些信息可以用来：
   - 验证初始估计的准确性
   - 指导后续执行阶段的优化
   - 为未来类似查询的优化提供参考

3. 保持计划的可重写性。即使在执行过程中，也应该能够根据实际情况对计划进行局部重写，而不是完全固化为物理计划。

这种动态优化支持对于处理复杂查询特别重要。例如，在处理一个包含多个嵌套子查询的复杂分析查询时，初始的优化决策可能基于不准确的估计。通过动态优化，系统可以在执行过程中根据实际情况调整策略，从而获得更好的性能。

# 调度器 : 执行层面的考虑


调度器作为连接优化和执行的关键桥梁，需要在运行时环境中平衡多个目标。在调度和执行层面，逻辑计划的设计需要为高效执行铺平道路, 完整的论述可以看[[理论/数据库系统/Bottom Up/1-Plan/Schduler/数据库查询调度与协调综述|数据库查询调度与协调综述]], 这一小节的内容只是一个简单的填充

这首先体现在并行执行机会的识别上。逻辑计划在构建时就应该标识出潜在的并行执行机会，例如：
1. 数据并行：标识出可以进行分区并行处理的算子，如全表扫描、聚合等。
2. 流水线并行：识别出可以流水线执行的算子序列，避免不必要的物化。
3. 独立并行：找出查询中相互独立的部分，如 UNION 的各个分支。

同时，逻辑计划还需要提供资源使用的预估信息。这些信息不需要像优化器那样精确，但要能够给出合理的范围，包括：

- 内存使用峰值：例如 Hash Join 的构建阶段
- CPU 计算强度：如复杂表达式的计算开销
- I/O 访问模式：顺序读取还是随机访问

这些信息帮助调度器在运行时做出更好的资源分配决策。例如，当处理一个包含多个 Hash Join 的查询时，调度器可以根据这些信息来决定是串行执行这些 Join 还是并行执行，以及如何分配内存资源。

## 调度器的核心任务和组件

调度器的核心任务可以分为三个主要方面：

1. **资源管理**
   - CPU 调度：线程池管理、任务分配和 CPU 核心的动态调整
   - 内存管理：包括内存分配、数据缓存和 NUMA 感知优化
   - I/O 管理：优化磁盘访问模式，平衡随机和顺序 I/O
   - 网络资源管理：在分布式环境中优化节点间通信

2. **并发控制**
   - 查询间资源竞争处理
   - 执行优先级管理
   - 负载均衡策略实施
   - 死锁检测和预防

3. **性能监控与调优**
   - 实时性能指标收集
   - 资源使用状况监控
   - 瓶颈识别和处理
   - 动态调整执行策略

## 调度器的核心任务
调度器是连接优化和执行的关键桥梁，它需要解决三个核心问题：

1. **资源分配**
考虑这样一个场景：数据库同时收到以下查询：
```sql
-- 查询1：需要大量内存的Hash Join
SELECT * FROM orders o 
JOIN customers c ON o.customer_id = c.id
JOIN products p ON o.product_id = p.id
WHERE o.amount > 1000;

-- 查询2：CPU密集的分析查询
SELECT customer_id, 
       COUNT(*), 
       AVG(amount),
       STDDEV(amount)
FROM orders 
GROUP BY customer_id
HAVING COUNT(*) > 100;

-- 查询3：I/O密集的全表扫描
SELECT * FROM large_table 
WHERE complex_condition(col1, col2);
```

调度器需要：
- 估算每个查询的资源需求
- 在查询间合理分配资源
- 避免资源竞争和死锁

2. **并发控制**
在高并发场景下，调度器要处理：
- 内存压力：防止 OOM
- I/O 竞争：优化磁盘访问
- CPU 调度：保证响应时间

3. **负载管理**
不同类型的查询需要不同的处理策略：
- 短查询：优先调度，快速响应
- 分析查询：控制资源使用
- 批处理：背景执行

# 总结

逻辑计划生成是连接 SQL 解析和查询执行的关键环节。它不仅需要正确地表达查询语义，还要为后续的优化和执行提供充分的机会和信息。通过本文的讨论，我们可以看到：

1. **语义表达**
   - 关系代数为逻辑计划提供了严谨的理论基础
   - 树形结构使得计划的转换和优化更加自然
   - 算子体系的设计需要平衡表达能力和优化空间

2. **优化支持**
   - 为优化器提供充分的统计信息和转换空间
   - 保留多种执行策略的可能性
   - 支持代价估算和计划比较

3. **执行准备**
   - 标识并行执行机会
   - 提供资源使用预估
   - 支持运行时的动态调整

## 展望：物理执行计划

逻辑计划生成之后，系统还需要将其转换为可执行的物理计划。这个过程涉及：

1. **执行算法选择**
   - 根据数据特征选择具体的算法实现
   - 考虑硬件特性（如 CPU 架构、内存层次）
   - 优化数据访问模式

2. **资源分配**
   - 确定内存使用策略
   - 规划 CPU 使用方式
   - 安排 I/O 操作

3. **并行化策略**
   - 选择并行粒度
   - 设计数据分区方案
   - 规划任务调度方式

这些内容将在后续的物理计划相关章节中详细讨论。

## 未来发展方向

1. **自适应逻辑计划**
   - 动态调整计划结构
   - 实时响应执行反馈
   - 支持增量优化

2. **机器学习增强**
   - 基数估计改进
   - 转换规则学习
   - 代价模型优化

3. **新型工作负载支持**
   - 流处理优化
   - 图计算支持
   - 机器学习算子